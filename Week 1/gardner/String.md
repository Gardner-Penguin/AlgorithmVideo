## String Matching(리트코드 28번, 796번)

- **시간복잡도 O(n)** → 외우기!

```python
String [abc abd abk] -> n개
subString [abk] -> 길이가 m

이때 String에 subString이 들어있는지 아닌지, 만약에 들어있다면 몇번째 index에 들어잇는지
subString을 찾는 시간복잡도 O(n)
```

- KMP

```python
abcdefgh에서
defgh 찾기

- 두 개의 포인터를 만들고
- 제일 앞에 둠
- 두 개의 포인트를 비교
- 만약에 다르면 origin string을 가리키고 있는 포인터를 다음칸으로
- 동일한 string을 찾을 때까지 반복

aaaaabb에서
aaab 찾기
- a가 매칭되기때문에 둘 다 한칸씩 뒤로 옮기면서 비교
- 근데 b와 a가 매칭되지 않기 때문에 아예 두번째 칸부터 다시 비교
-> O(n*m) = 효율적이지 않다...

aaaaab
012340

aaaabb와
aaaab 비교
비교당하는 배열의 미스매치가 일어난 인덱스와 
비교하려고 하는 배열의 미스매치가 일어난 -1 인덱스와 비교
```

- Rabin-Kuup(Rolling-hash)
    - 찾고자하는 문자열의 길이, 해시값을 알아낸다 (aaaab → 5, 42)
    - 비교하고자 하는 문자열에서 크기 5의 슬라이딩 윈도우를 진행 → 할 때마다 해시값을 계산
    - 해시값이 동일하면 해시 충돌이 일어날 수 있기 때문에 각각 문자열을 모두 비교해줌 → 일치하면 찾았다!

## Palindrome(리트코드 680번)

- 시간 복잡도 O(n)
- 앞에서 읽을 때, 뒤에서 읽을 때 동일한 문자열
- 투 포인터(앞, 뒤 하나씩, 한 칸씩 업데이트), 만나거나 스왑이 되는 케이스에서 멈추면 됨
- 글자가 아닌 특수 문자가 들어가 있는 경우에는 A~Z, a~z 사이에 들어있는지 확인하고 만약에 아니라면 알파벳이 나올 때까지 계속 이동해주면 됨
- 한 문자가 빠졌을 때 palindrome인지 확인하는 경우, 다른 문자를 가리킬 때 둘 중에 어느 문자를 뺄건지 두 상황을 시뮬레이션 해보면 됨

## Add Strings(리트코드 415번)

- Int로 각각 변환 후 더하고 다시 string으로 변환
- 두 개의 포인터를 만들고 자리 바꿈 수 carry 생성
    - carry + 두 포인터가 가르키는 수를 10으로 나눈 몫과 나머지를 구하고
    - 몫을 carry에 업데이트, 나머지는 char로 저장
    - 저장할 때 array 마지막에 덧붙이는 식으로 저장하고 마지막에 뒤집어서 return O(1)

## Group Anagrams(리트코드 49번)

- Hash Map(key-value)
- 모두 각각 sorting, key: abc(sorting된 단어), value: 원래 단어
    - 각각 단어 정렬 O(mlogm), 해시맵에 넣는 경우 n개인 경우 O(n*mlogm)
    - Space complexity: O(n*m)
- key를 다르게 만드는 경우 → 각 단어의 알파벳이 몇개씩 들어가는지 해시맵에 들어갈 키를 정의해주면 됨
    - 하나의 테이블을 생성하고(a~z가 키로 들어가있는) 각 알파벳이 몇개씩 들어가있는지 체크해주면 됨
    - O(n*m) / O(n*m)

## Longest Substring w/o Repeats(리트코드 3번)

- 주어진 배열에서 겹치지않는 문자열의 최대 길이를 찾는 법

```python
[ a b c g a b d d ] -> [cgabd]

[ d d d d d ] -> [d]
```

- Brute Force
    - 투 포인터로 모든 길이의 substring을 만들고 길이를 체크해서 최대길이를 알아내기
    - O(n^3)
- 투 포인터
    - 첫번째 두벉쨰 포인터에서 시작해서 겹치는게 없으면 계속 뒤 포인터를 한칸씩 옮겨줌
    - 만약에 겹치는 알파벳이 생기면 앞 포인터를 뒤로 한칸 옮겨줌
    - advance
    - 중복 여부는 해시 맵으로 구현 → -1로 초기화, 값이 나오면 value를 해당 발견 인덱스로 업데이트
    - 만약에 중복된걸 발견하면 저장된 인덱스 다음껄로 앞 포인터를 옮겨줌
    - O(n) / O(1)